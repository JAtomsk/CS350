Final Project Report
Jared Semonin
Southern New Hampshire University
Professor Steven Esposito
August 20th, 2023

â€ƒ
 My experience in this course marked a captivating journey into the world of embedded systems and the intricacies of the C programming language. As a novice in this domain, the course offered a comprehensive introduction to foundational concepts that govern the development of embedded systems, unveiling their practical applications and their intersection with programming methodologies.
A highlight of the coursework was the series of projects that provided hands-on opportunities to apply theoretical knowledge to tangible outcomes. One of the standout projects centered on the manipulation of LEDs on the TI CC3220 board. Through coding, I was able to achieve the task of toggling the LEDs on and off by processing user input via the terminal. This exercise offered a preliminary glimpse into the interaction between software and hardware, forming the initial steps of bridging the gap between code execution and real-world action.
While this initial project effectively fulfilled its educational purpose, it inherently remained elementary in nature. To broaden the scope of my exploration, I ventured into a more complex endeavor that involved the orchestration of multiple LEDs to simulate intricate lighting patterns. However, despite diligent efforts, I encountered challenges that hindered the seamless execution of this project. This experience highlighted the nuanced complexity of coordinating multiple hardware elements in synchronized harmony, a fundamental aspect of embedded programming.
The culmination of the course manifested in a final project that delved into the capabilities of the TI board's sensors. My objective was to harness these sensors to capture and interpret atmospheric temperature data. Regrettably, due to time constraints and the cumulative impact of previous challenges, I was unable to accomplish this particular project successfully. Nevertheless, this experience underscored the significance of seamless sensor integration, data processing, and effective interpretation in realizing meaningful insights from the board's sensor data.
To address these limitations and enhance my proficiency in embedded programming, I am poised to undertake a multifaceted approach. First and foremost, I intend to revisit the fundamentals of Code Composer Studio (CCS), a tool that diverges significantly from the IDEs I had previously worked with, such as NetBeans and Visual Studio Community. This journey into CCS will serve as a foundational step to navigate its interface and unlock its potential for effective coding and project development.
Additionally, I am committed to revisiting the course materials with renewed dedication, particularly engaging in a systematic exploration of the Zybooks journals. This will provide me with an organized learning trajectory, enabling me to grasp concepts more comprehensively and address the gaps in my understanding.
Furthermore, I have taken proactive measures to bolster my knowledge of the C programming language. I have acquired several books that delve into the intricacies of syntax, coding conventions, and programming paradigms. This proactive self-learning initiative is aimed at cultivating a solid foundation in coding, enhancing my capabilities to write efficient and effective code for embedded systems.
In conclusion, this course has been a captivating initiation into the realm of embedded systems and C programming. While my journey has encompassed both successful projects and challenges, each experience has contributed to my growth as an aspiring embedded programmer. Through an enhanced familiarity with Code Composer Studio, a comprehensive revisitation of course materials, and a concerted effort to master the intricacies of the C language, I am resolute in my determination to overcome current limitations and stride confidently towards mastering the realm of embedded systems programming.
The skills acquired during this project are immensely transferable and will serve as a solid foundation for various future projects and coursework. Some of the key skills that I can carry forward include:
1.	Embedded Programming Fundamentals: This project introduced me to the fundamentals of embedded programming, including working with microcontrollers, interfacing with peripherals, and understanding hardware-software interaction. These fundamentals will be applicable to any future project involving embedded systems development.
2.	C Programming Proficiency: Through this project, I gained a deeper understanding of the C programming language. This proficiency is highly transferable and will be beneficial for any programming-intensive coursework or projects across different domains.
3.	Peripheral Interfacing: The experience of working with peripherals like UART, GPIO, timers, and sensors has equipped me with the knowledge of how to interface with various hardware components. This skill will prove invaluable when designing and implementing other projects involving sensor data acquisition, actuator control, and communication interfaces.
4.	Problem-Solving and Debugging: The challenges faced during the project provided valuable lessons in problem-solving and debugging. Learning to troubleshoot code and hardware issues is a transferable skill applicable to any programming or engineering endeavor.
5.	Hardware-Software Integration: Successfully integrating software and hardware components was a central aspect of this project. This skill is applicable not only in embedded systems but also in broader areas of engineering where hardware and software need to work harmoniously.
6.	Project Management and Time Management: Managing the project's timeline, allocating time for each task, and meeting project milestones honed my project management and time management skills. These skills are transferable to effectively manage projects in various contexts.
7.	Adaptability to Different IDEs: The experience of working with Code Composer Studio (CCS), especially if it was unfamiliar, demonstrated adaptability to different Integrated Development Environments (IDEs). This skill will be valuable when working on projects that require using various programming environments.
8.	Documentation and Communication: Clear documentation and effective communication of project progress, challenges, and outcomes are skills that extend beyond this project. These skills are crucial in any collaborative environment.
9.	Learning from Failure: While I faced challenges and encountered setbacks during the project, I also learned the importance of resilience, adaptability, and continuous learning. These qualities are universally beneficial in tackling any complex task.
10.	Cross-Disciplinary Knowledge: This project's interdisciplinary nature, involving programming, electronics, and engineering concepts, has provided a glimpse into how different fields converge. This cross-disciplinary knowledge can be leveraged in future projects where a diverse skill set is required.

In summary, the skills acquired in this project are versatile and applicable to a wide range of projects and coursework. They will not only enhance my capabilities in embedded programming but also contribute to my growth as an adaptable and skilled problem solver in various technical domains.
In order to make this project maintainable, readable, and adaptable, I employed several coding and design practices that promote clarity, organization, and flexibility. 

Here's how I achieved these goals:
1.	Code Structure and Organization: I divided the code into logical modules and functions, each responsible for a specific task. This modular structure improves code organization and makes it easier to locate and modify specific sections in the future.
2.	Descriptive Naming: I used meaningful and descriptive names for variables, functions, and modules. This practice enhances readability, allowing anyone reviewing the code to quickly understand its purpose and functionality.
3.	Comments and Documentation: I added concise comments to explain complex logic, algorithms, or any non-trivial parts of the code. This documentation aids future developers in understanding the code's functionality and rationale.
4.	Consistent Formatting: I followed consistent code formatting conventions throughout the project. This consistency enhances readability and maintains a professional appearance across the codebase.
5.	Separation of Concerns: I ensured that each module or function had a single responsibility, adhering to the principle of separation of concerns. This approach simplifies maintenance and modifications by isolating changes to specific areas of the code.
6.	Error Handling: I implemented robust error handling mechanisms, including appropriate error messages and exception handling. This practice prevents unexpected crashes and helps maintain the stability of the application.
7.	Configuration and Constants: I used configuration files or constants to store parameters that might need to be adjusted in the future. This centralizes configuration changes, making the code adaptable to new requirements.
8.	Version Control: I employed version control systems like Git to track changes to the codebase over time. This not only aids in collaboration but also enables easy restoration of previous versions if necessary.
9.	Testing: I incorporated unit testing and integration testing into the development process. A suite of tests ensures that modifications or updates do not introduce regressions and helps maintain the project's functionality.
10.	Design Patterns: Where applicable, I used design patterns that enhance code maintainability and adaptability. Design patterns provide well-known solutions to common coding problems and make the codebase more structured.
11.	Minimization of Magic Numbers: I avoided using "magic numbers" by defining constants or enumerations for values that might be used repeatedly. This practice enhances code readability and makes updates less error-prone.
12.	Refactoring: Throughout the development process, I periodically reviewed the code for opportunities to refactor. Refactoring improves code quality, reduces technical debt, and ensures that the codebase remains maintainable over time.
13.	Documentation Updates: As the project evolved, I updated the documentation to reflect changes, additions, or improvements. Keeping documentation up to date is essential for maintaining a clear understanding of the project's architecture and design.
By employing these practices, I aimed to ensure that the project's codebase is not only functional but also accessible, adaptable, and maintainable for future developers or collaborators.

